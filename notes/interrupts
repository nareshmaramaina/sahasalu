
Interrupt is an event that alter sequence of exectiobns execution  by a processor in corresponding to electrical signals rasied by h/w circuts by the inside and outside CPU. 


Driver interrupt handler :-

It is register with interrupt management subsystem through kernel IRQ number. 

These functions are invoked by interrupt management layer upon suspending processor schedular and masking interrupt in local CPU. Local CPU's  interrputs are tuned only on FSPA, 

Driver ISR's must be register as instance of type struct IRQ action with interrupt sub system.
 

IRQ descriptor table is the core data structure which hlods reference 	of driver interrupt hanlders and kernel IRQ properties 



Software options for resource partioning 

CPU affinity and interrupt affinity 
Contianers virtualization 

Hardware option for resource porting / allocations 

* Partition hardware to assign dedicated processing powr for data processing and control ooerations 



Do's and don't s to achieve deterministic exection of ISR's 

Don't :- 
1) Avoid memory allocation calls 
2) Avoid process sharing data structr or buffers 
3) Avoid preemption time delay calls ( mdelay , msleep, schedule)
4) Avoid blcoking calls 
5) Avoid user space calls  ( Copy_from_user / to_user , kmap/pad map )
6) Avoid printk statements 
7) Avoid memcpy  or looping code 

Do's:- 

1) Use pre allocate memory blocks ( kmem chaches) 
2) Use Engine DMA buffers b/w device and device buffers
3) Identify interrupt non critical operations and differ them to run later


int request_irq(irq,my_interrupt,IRQF_SHARED,"my_interrupts",&my_dev_id);

1 Irq , Spcifie interrupt number to allocate

2 my_interrupt, function pointer to acutal interrupt handler, this function invoked when operating system got given interrupt  
irq_return_t	(*interrupt ) ( int , void *)

3. Flags - 	IRQF_DISABLED , If this set  all interrupts are disabled when exectiong interrupt handler 

	IRQF_TIMER —This flag specifies that this handler processes interrupts for the sys-
tem timer.
	IRQF_SHARED —This flag specifies that the interrupt line can be shared among mul-
tiple interrupt handlers.
	IRQF_SAMPLE_RANDOM —This flag specifies that interrupts generated by this device
should contribute to the kernel entropy pool.The kernel entropy pool provides
truly random numbers derived from various random events.


static irqreturn_t intr_handler(int irq, void *dev); 



Interrupts disable intertrupt subsystem on current processor or mask out the interrupt line for entire machine

By disabling interrupts you can garuntee that an interrupt handler never preempting your current code, 

Moreever disabling interrupts also disabling preemption.




local_irq_disable(); enable // Set clear interrupts 


Instead of that complexity , 

WE can use save and restore mechanism 







local_irq_save(); // save the current interrupts state ,and Disable the interrupts, 
local_irq_restore(); // interrupts are restored to their previous state 


Some times you need to disable only a specific line for the entire system. This is called mask out the interrupt line. 

disable_irq ( unsigned int irq ); // Disable  given interrupt line in interrupt  controller, disable delivery of the given interrupt to all processors of the system 
 
disable_irq_nosync ( unsigned int irq ); // Does not wait for 

enalbe_irq(irq);

sychronize_irq(irq); // Wait for specific handler to exit 

irqs_disabled(); non zero if the interrupt system on the local processor is disabled 

The macro irqs_disabled() , defined in <asm/system.h> , returns nonzero if the
interrupt system on the local processor is disabled. Otherwise, it returns zero.
Two macros, defined in <linux/hardirq.h> , provide an interface to check the ker-
nel’s current context.They are
in_interrupt()
in_irq()
The most useful is the first: It returns nonzero if the kernel is performing any type of
interrupt handling.This includes either executing an interrupt handler or a bottom half
handler.The macro in_irq() returns nonzero only if the kernel is specifically executing
an interrupt handler.

Function Description
local_irq_disable() Disables local interrupt delivery
local_irq_enable() Enables local interrupt delivery
local_irq_save() Saves the current state of local interrupt delivery and then
disables it
local_irq_restore() Restores local interrupt delivery to the given state
disable_irq() Disables the given interrupt line and ensures no handler on
the line is executing before returning
disable_irq_nosync() Disables the given interrupt line
enable_irq() Enables the given interrupt line
irqs_disabled() Returns nonzero if local interrupt delivery is disabled; other-
wise returns zero
in_interrupt() Returns nonzero if in interrupt context and zero if in process
context
in_irq() Returns nonzero if currently executing an interrupt handler
and zero otherwise
