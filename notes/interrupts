
Interrupt is an event that alter sequence of instructions execution  by a processor in corresponding to electrical signals rasied by h/w circuts by the inside and outside CPU. 


Driver interrupt handler :-

It is register with interrupt management subsystem through kernel IRQ number. 

These functions are invoked by interrupt management layer upon suspending processor schedular and masking interrupt in local CPU. Local CPU's  interrputs are tuned only on FSPA, 

Driver ISR's must be register as instance of type struct IRQ action with interrupt sub system.
 

IRQ descriptor table is the core data structure which hlods reference 	of driver interrupt hanlders and kernel IRQ properties 



Software options for resource partioning 

CPU affinity and interrupt affinity 
Contianers virtualization 

Hardware option for resource porting / allocations 

* Partition hardware to assign dedicated processing powr for data processing and control ooerations 



Do's and don't s to achieve deterministic exection of ISR's 

Don't :- 
1) Avoid memory allocation calls 
2) Avoid process sharing data structr or buffers 
3) Avoid preemption time delay calls ( mdelay , msleep, schedule)
4) Avoid blcoking calls 
5) Avoid user space calls  ( Copy_from_user / to_user , kmap/pad map )
6) Avoid printk statements 
7) Avoid memcpy  or looping code 

Do's:- 

1) Use pre allocate memory blocks ( kmem chaches) 
2) Use Engine DMA buffers b/w device and device buffers
3) Identify interrupt non critical operations and differ them to run later


int request_irq(irq,my_interrupt,IRQF_SHARED,"my_interrupts",&my_dev_id);

1 Irq , Spcifie interrupt number to allocate

2 my_interrupt, function pointer to acutal interrupt handler, this function invoked when operating system got given interrupt  
irq_return_t	(*interrupt ) ( int , void *)

3. Flags - 	IRQF_DISABLED , If this set  all interrupts are disabled when exectiong interrupt handler 

	IRQF_TIMER —This flag specifies that this handler processes interrupts for the sys-
tem timer.
	IRQF_SHARED —This flag specifies that the interrupt line can be shared among mul-
tiple interrupt handlers.
	IRQF_SAMPLE_RANDOM —This flag specifies that interrupts generated by this device
should contribute to the kernel entropy pool.The kernel entropy pool provides
truly random numbers derived from various random events.


static irqreturn_t intr_handler(int irq, void *dev); 



Interrupts disable intertrupt subsystem on current processor or mask out the interrupt line for entire machine

By disabling interrupts you can garuntee that an interrupt handler never preempting your current code, 

Moreever disabling interrupts also disabling preemption.




local_irq_disable(); enable // Set clear interrupts 


Instead of that complexity , 

WE can use save and restore mechanism 







local_irq_save(); // save the current interrupts state ,and Disable the interrupts, 
local_irq_restore(); // interrupts are restored to their previous state 


Some times you need to disable only a specific line for the entire system. This is called mask out the interrupt line. 

disable_irq ( unsigned int irq ); // Disable  given interrupt line in interrupt  controller, disable delivery of the given interrupt to all processors of the system 
 
disable_irq_nosync ( unsigned int irq ); // Does not wait for 

enalbe_irq(irq);

sychronize_irq(irq); // Wait for specific handler to exit 

irqs_disabled(); non zero if the interrupt system on the local processor is disabled 

The macro irqs_disabled() , defined in <asm/system.h> , returns nonzero if the
interrupt system on the local processor is disabled. Otherwise, it returns zero.
Two macros, defined in <linux/hardirq.h> , provide an interface to check the ker-
nel’s current context.They are

in_interrupt()

in_irq() : The most useful is the first: It returns nonzero if the kernel is performing any type of
interrupt handling.This includes either executing an interrupt handler or a bottom half
handler.The macro in_irq() returns nonzero only if the kernel is specifically executing
an interrupt handler.

Function Description

local_irq_disable() Disables local interrupt delivery

local_irq_enable() Enables local interrupt delivery

local_irq_save() Saves the current state of local interrupt delivery and then
disables it

local_irq_restore() Restores local interrupt delivery to the given state

disable_irq() Disables the given interrupt line and ensures no handler on
the line is executing before returning

disable_irq_nosync() Disables the given interrupt line

enable_irq() Enables the given interrupt line

irqs_disabled() Returns nonzero if local interrupt delivery is disabled; other-
wise returns zero

in_interrupt() Returns nonzero if in interrupt context and zero if in process
context

in_irq() Returns nonzero if currently executing an interrupt handler
and zero otherwise

A Softirq never preempts the another softirqs, The only one preempty the softirq is interrupt handler


Softirqs are reserved for the most timing-critical and important bottom-half processing
on the system. Currently, only two subsystems--networking and block devices--directly
use softirqs.Additionally, kernel timers and tasklets are built on top of softirqs. If you add a
new softirq, you normally want to ask yourself why using a tasklet is insufficient.Tasklets
are dynamically created and are simpler to use because of their weaker locking require-
ments, and they still perform quite well. Nonetheless, for timing-critical applications that
can do their own locking in an efficient way, softirqs might be the correct solution.



Softirq :- 


void softirq_handler(struct softirq_action *) ;

open_softirq(HI_SOFTIRQ,BH);

raise_softirq(HI_SOFTIRQ);





Tasklet :- 

DECLARE_TASKLET(my_tasklet, my_tasklet_handler, dev); // Statically 
This line is equivalent to
struct tasklet_struct my_tasklet = { NULL, 0, ATOMIC_INIT(0),
my_tasklet_handler, dev };

This creates a tasklet named my_tasklet enabled with tasklet_handler as its han-
dler.The value of dev is passed to the handler when it is executed.

To initialize a tasklet given an indirect reference (a pointer) to a dynamically created
struct tasklet_struct , t , call tasklet_init() :

tasklet_init(t, tasklet_handler, dev);
/* dynamically as opposed to statically */


tasklet_schedule(&my_tasklet);


DECLARE_TASKLET_DISABLED(name, func, data);
tasklet_enable() enables the tasklet.This function also must be called
created with DECLARE_TASKLET_DISABLED() is usable. For example:

tasklet_disable(&my_tasklet);

before a tasklet
/* tasklet is now disabled */
/* we can now do stuff knowing that the tasklet cannot run .. */
tasklet_enable(&my_tasklet);
/* tasklet is now enabled */
You can remove a tasklet from the pending queue via tasklet_kill() .This function
receives a pointer as a lone argument to the tasklet's tasklet_struct . Removing a
scheduled tasklet from the queue is useful when dealing with a tasklet that often resched-
ules itself.This function first waits for the tasklet to finish executing and then it removes
the tasklet from the queue. Nothing stops some other code from rescheduling the tasklet,
of course.This function must not be used from interrupt context because it sleep



Work Queues : -


DECLARE_WORK(name, void (*func)(void *), void *data);
	This statically creates a work_struct structure named name with handler function
and argument data .
Alternatively, you can create work at runtime via a pointer:
func

INIT_WORK(struct work_struct *work, void (*func)(void *), void *data);
This dynamically initializes the work queue pointed to by work with handler function
and argument data .





Process 0 is a special process (called swapper or idle process) which runs when the system is idle, i.e. no other process is scheduled. It is the only process which can invoke the idle() system call.

This is the first process to be spawned, which then creates init (PID 1) which starts other processes.

root         1     0 /sbin/init

You can also check man idle










An interrupt is an event that changes the sequence of instructions executed by the processor.
There are two different kinds of interrupts:

    Synchronous interrupt (Exception) produced by the CPU while processing instructions
    Asynchronous interrupt (Interrupt) issued by other hardware devices

Exceptions are caused by programming errors (f.e. Divide error, Page Fault, Overflow) that must be handled by the kernel. He sends a signal to the program and tries to recover from the error.

The following two exceptions are classified:

    Processor-detected exception generated by the CPU while detecting a anomalous condition; divided into three groups: Faults can generally be corrected, Traps report an execution, Aborts are serious errors.
    Programmed exception requested by the programmer, handled like a trap



Table 4-2. Interrupt vectors in Linux

Vector range
	

Use

0-19 (0x0-0x13)
	

Nonmaskable interrupts and exceptions

20-31 (0x14-0x1f)
	

Intel-reserved

32-127 (0x20-0x7f)
	

External interrupts (IRQs)

128 (0x80)
	

Programmed exception for system calls (see Chapter 10)

129-238 (0x81-0xee)
	

External interrupts (IRQs)

239 (0xef)
	

Local APIC timer interrupt (see Chapter 6)

240 (0xf0)
	

Local APIC thermal interrupt (introduced in the Pentium 4 models)

241-250 (0xf1-0xfa)
	

Reserved by Linux for future use

251-253 (0xfb-0xfd)
	

Interprocessor interrupts (see the section "Interprocessor Interrupt Handling" later in this chapter)

254 (0xfe)
	

Local APIC error interrupt (generated when the local APIC detects an erroneous condition)

255 (0xff)
	

Local APIC spurious interrupt (generated if the CPU masks an interrupt while the hardware device raises it)
